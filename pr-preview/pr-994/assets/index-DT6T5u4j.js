import{c as W}from"./create-context-CDNpEWXj.js";import{b as X,d as Y,e as Z,M as q,I as j,i as h,f as z,w as D,t as tt,g as et}from"./factory-R3eP5z4B.js";import{r as o}from"./index-Bj2TM2QZ.js";import{r as k}from"./index-CVNl4AZj.js";import"./jsx-runtime-D_zvdyIk.js";const[lt,dt]=W({name:"LocaleContext",hookName:"useLocaleContext",providerName:"<LocaleProvider />",strict:!1,defaultValue:{dir:"ltr",locale:"en-US"}});function rt(t){return new Proxy({},{get(a,c){return c==="style"?f=>t({style:f}).style:t}})}var gt=()=>t=>Array.from(new Set(t)),H=typeof globalThis.document<"u"?o.useLayoutEffect:o.useEffect;function U(t){const a=t().value??t().defaultValue,c=t().isEqual??Object.is,[f]=o.useState(a),[S,v]=o.useState(f),m=t().value!==void 0,y=o.useRef(S);y.current=m?t().value:S;const b=o.useRef(y.current);H(()=>{b.current=y.current},[S,t().value]);const E=g=>{var C,M;const i=b.current,l=z(g)?g(i):g;t().debug&&console.log(`[bindable > ${t().debug}] setValue`,{next:l,prev:i}),m||v(l),c(l,i)||(M=(C=t()).onChange)==null||M.call(C,l,i)};function w(){return m?t().value:S}return{initial:f,ref:y,get:w,set(g){(t().sync?k.flushSync:h)(()=>E(g))},invoke(g,i){var l,C;(C=(l=t()).onChange)==null||C.call(l,g,i)},hash(g){var i,l;return((l=(i=t()).hash)==null?void 0:l.call(i,g))??String(g)}}}function nt(t){const a=o.useRef(t);return{get(c){return a.current[c]},set(c,f){a.current[c]=f}}}var ut=(t,a)=>{const c=o.useRef(!1),f=o.useRef(!1);o.useEffect(()=>{if(c.current&&f.current)return a();f.current=!0},[...(t??[]).map(S=>typeof S=="function"?S():S)]),o.useEffect(()=>(c.current=!0,()=>{c.current=!1}),[])};function Rt(t,a={}){var F,J,_,B;const c=o.useMemo(()=>{const{id:r,ids:e,getRootNode:n}=a;return X({id:r,ids:e,getRootNode:n})},[a]),f=(...r)=>{t.debug&&console.log(...r)},S=((F=t.props)==null?void 0:F.call(t,{props:Y(a),scope:c}))??a,v=st(S),m=(J=t.context)==null?void 0:J.call(t,{prop:v,bindable:U,scope:c,flush:G,getContext(){return b},getComputed(){return T},getRefs(){return M}}),y=K(m),b={get(r){var e;return(e=y.current)==null?void 0:e[r].ref.current},set(r,e){var n;(n=y.current)==null||n[r].set(e)},initial(r){var e;return(e=y.current)==null?void 0:e[r].initial},hash(r){var n,u;const e=(n=y.current)==null?void 0:n[r].get();return(u=y.current)==null?void 0:u[r].hash(e)}},E=o.useRef(new Map),w=o.useRef(null),g=o.useRef(null),i=o.useRef({type:""}),l=()=>({...i.current,current(){return i.current},previous(){return g.current}}),C=()=>({...R,matches(...r){return r.includes(R.ref.current)},hasTag(r){var e,n;return!!((n=(e=t.states[R.ref.current])==null?void 0:e.tags)!=null&&n.includes(r))}}),M=nt(((_=t.refs)==null?void 0:_.call(t,{prop:v,context:b}))??{}),N=()=>({state:C(),context:b,event:l(),prop:v,send:$,action:L,guard:P,track:ut,refs:M,computed:T,flush:G,scope:c,choose:I}),L=r=>{const e=z(r)?r(N()):r;if(!e)return;const n=e.map(u=>{var d,x;const s=(x=(d=t.implementations)==null?void 0:d.actions)==null?void 0:x[u];return s||D(`[zag-js] No implementation found for action "${JSON.stringify(u)}"`),s});for(const u of n)u==null||u(N())},P=r=>{var e,n;return z(r)?r(N()):(n=(e=t.implementations)==null?void 0:e.guards)==null?void 0:n[r](N())},A=r=>{const e=z(r)?r(N()):r;if(!e)return;const n=e.map(s=>{var x,p;const d=(p=(x=t.implementations)==null?void 0:x.effects)==null?void 0:p[s];return d||D(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`),d}),u=[];for(const s of n){const d=s==null?void 0:s(N());d&&u.push(d)}return()=>u.forEach(s=>s==null?void 0:s())},I=r=>tt(r).find(e=>{let n=!e.guard;return et(e.guard)?n=!!P(e.guard):z(e.guard)&&(n=e.guard(N())),n}),T=r=>{Z(t.computed,"[zag-js] No computed object found on machine");const e=t.computed[r];return e({context:b,event:l(),prop:v,refs:M,scope:c,computed:T})},R=U(()=>({defaultValue:t.initialState({prop:v}),onChange(r,e){var u,s,d,x;if(e){const p=E.current.get(e);p==null||p(),E.current.delete(e)}e&&L((u=t.states[e])==null?void 0:u.exit),L((s=w.current)==null?void 0:s.actions);const n=A((d=t.states[r])==null?void 0:d.effects);if(n&&E.current.set(r,n),e===j){L(t.entry);const p=A(t.effects);p&&E.current.set(j,p)}L((x=t.states[r])==null?void 0:x.entry)}})),O=o.useRef(void 0),V=o.useRef(q.NotStarted);H(()=>{queueMicrotask(()=>{const n=V.current===q.Started;V.current=q.Started,f(n?"rehydrating...":"initializing...");const u=O.current??R.initial;R.invoke(u,n?R.get():j)});const r=E.current,e=R.ref.current;return()=>{f("unmounting..."),O.current=e,V.current=q.Stopped,r.forEach(n=>n==null?void 0:n()),E.current=new Map,w.current=null,queueMicrotask(()=>{L(t.exit)})}},[]);const Q=()=>"ref"in R?R.ref.current:R.get(),$=r=>{queueMicrotask(()=>{var x,p;if(V.current!==q.Started)return;g.current=i.current,i.current=r,f("send",r);let e=Q();const n=((x=t.states[e].on)==null?void 0:x[r.type])??((p=t.on)==null?void 0:p[r.type]),u=I(n);if(!u)return;w.current=u;const s=u.target??e;f("transition",u);const d=s!==e;d?k.flushSync(()=>R.set(s)):u.reenter&&!d?R.invoke(e,e):L(u.actions??[])})};return(B=t.watch)==null||B.call(t,N()),{state:C(),send:$,context:b,prop:v,scope:c,refs:M,computed:T,event:l(),getStatus:()=>V.current}}function K(t){const a=o.useRef(t);return a.current=t,a}function st(t){const a=K(t);return function(f){return a.current[f]}}function G(t){queueMicrotask(()=>{k.flushSync(()=>t())})}var pt=rt(t=>t);export{lt as L,Rt as a,gt as c,pt as n,dt as u};
